<?php

namespace Copiaincolla\MetaTagsBundle\Loader;

use Symfony\Bundle\FrameworkBundle\Routing\Router;
use Symfony\Component\Routing\Route;
use Doctrine\ORM\EntityManager;

/**
 * Urls loader.
 */
class UrlsLoader
{
    protected $config;

    protected $router;
    protected $em;
    protected $container;

    protected $loadedBundlesRegex = "";
    protected $dynamic_routes_default_params;

    /**
     * @param array $config
     * @param \Symfony\Bundle\FrameworkBundle\Routing\Router $router
     * @param \Doctrine\ORM\EntityManager $em
     * @param $container
     */
    public function __construct(array $config = array(), Router $router, EntityManager $em, $container)
    {
        $this->config = $config;

        $this->router = $router;
        $this->em = $em;
        $this->container = $container;

        // set defaults parameters for all routes if specified
        $this->dynamic_routes_default_params = (array_key_exists('default_params', $this->config['dynamic_routes'])) ? $this->config['dynamic_routes']['default_params'] : array();

        $this->generateLoadedBundlesRegex();
    }

    /**
     * Get all urls
     *
     * Return an associative array of (relative) urls organized by route name
     * es: $output = array(
     *         'homepage' => array([url]),
     *         'products' => array([url], [url], [url], [url], ...),
     *         ...
     * )
     *
     * User will be able to set meta tags for each url
     *
     * @return array
     */
    public function getUrls($excludeAlreadyAssociated = false)
    {
        // associative array [route name] => [array urls] to be returned
        $output = array();


        // removing the baseUrl to generate baseUrl independent urls
        $baseUrl = $this->router->getContext()->getBaseUrl();
        $this->router->getContext()->setBaseUrl(null);

        // iterate on selected routes to generate urls
        foreach ($this->router->getRouteCollection()->all() as $name => $route) {

            if (!$this->isRouteExposed($route)) {
                continue;
            }

            // array of urls generated by route $name
            $output[$name] = array();

            // route needs datas from database
            if (array_key_exists($name, $this->config['dynamic_routes']['routes'])) {

                // load objects from repository
                if (array_key_exists('repository', $this->config['dynamic_routes']['routes'][$name])) {
                    $repository = $this->config['dynamic_routes']['routes'][$name]['repository'];

                    // data fetched from database
                    if (isset($this->config['dynamic_routes']['routes'][$name]['repository_fetch_function'])) {
                        $repositoryFunction = $this->config['dynamic_routes']['routes'][$name]['repository_fetch_function'];
                        $data = $this->em->getRepository($repository)->$repositoryFunction();
                    } else {
                        $data = $this->em->getRepository($repository)->findAll();
                    }

                    // generate a url for each object
                    foreach ($data as $obj) {
                        $preparedRoutes = $this->prepareDynamicUrls($name, $route, $obj, $this->config['dynamic_routes']['routes'][$name]);

                        if ($preparedRoutes) {
                            foreach ($preparedRoutes as $preparedRoute ) {
                                $output[$name][] = $preparedRoute;
                            }
                        }
                    }
                }

                // route does not need variables to be loaded by objects in database
            } else {
                $preparedRoute = $this->prepareUrl($name, $route);

                if ($preparedRoute) {
                    $output[$name][] = $preparedRoute;
                }
            }
        }

        /*
         * load a custom service defined by user, to load additional generated routes
         */
        if (array_key_exists('urls_loader_custom_service', $this->config) && $this->config['urls_loader_custom_service'] != null) {

            // load custom service
            $urlsLoaderCustomService = $this->container->get($this->config['urls_loader_custom_service']);

            // merge generated urls
            foreach ($urlsLoaderCustomService->getUrls() as $name => $preparedRoute) {
                $output[$name] = $preparedRoute;
            }
        }

        // restore the original baseURl
        $this->router->getContext()->setBaseUrl($baseUrl);

        // purge urls from already associated urls
        if ($excludeAlreadyAssociated) {
            $output = $this->purgeRoutesArrayFromAlreadyAssociatedUrls($output);
        }

        // purge $output from routes with no urls generated
        foreach ($output as $route => $urls) {
            if (count($output[$route]) <= 0) {
                unset($output[$route]);
            }
        }

        // sort the urls array by route names
        ksort($output);

        return $output;
    }

    /**
     * Generate urls fetching the route variables from the object $obj and the config
     *
     * @param string $name route name
     * @param Route $route Route object
     * @param mixed $obj object fetched from database
     * @param array $dynamicRouteArray array from bundle config
     * @return array $output always return an array, even if there's only one value
     */
    private function prepareDynamicUrls($name, $route, $obj, $dynamicRouteArray)
    {
        // route parameters
        $routeParameters = array();

        // set route variables fetching the value from $obj property or method
        if (array_key_exists('object_params', $dynamicRouteArray)) {

            foreach ($dynamicRouteArray['object_params'] as $k => $param) {

                // get the value from $obj by accessing the variable name or calling a method
                if (isset($obj->$param)) {
                    $routeParameters[$k] = $obj->$param;
                } else if (method_exists($obj, $param)) {
                    $routeParameters[$k] = call_user_func_array(array($obj, $param), array());
                } else if (method_exists($obj, 'get' . $param)) {
                    $routeParameters[$k] = call_user_func_array(array($obj, 'get' . $param), array());
                } else if (method_exists($obj, 'is' . $param)) {
                    $routeParameters[$k] = call_user_func_array(array($obj, 'is' . $param), array());
                }
            }
        }

        $output = array();

        // process [route_name]['fixed_params']
        if (count($dynamicRouteArray['fixed_params']) > 0) {
            foreach ($dynamicRouteArray['fixed_params'] as $k => $params) {
                if (is_array($params)) {
                    foreach ($params as $p => $param) {
                        $routeParameters[$k] = $dynamicRouteArray['fixed_params'][$k][$p];

                        $output[] = $this->prepareUrl($name, $route, $routeParameters);
                    }
                } else {
                    $routeParameters[$k] = $dynamicRouteArray['fixed_params'][$k];

                    $output[] = $this->prepareUrl($name, $route, $routeParameters);
                }
            }
        } else {
            $output[] = $this->prepareUrl($name, $route, $routeParameters);
        }


        // return the url
        return $output;
    }

    /**
     * Generate a url
     *
     * If route has some variables, try to read $defaultVariables, then bundle config
     *
     * @param string $name route name
     * @param Route $route Route object
     * @param array $defaultVariables array of [routa variable] => [value]
     */
    private function prepareUrl($name, $route, $defaultVariables = array())
    {
        // get compiled route
        $compiledRoute = $route->compile();

        // variables required to generate the route
        $variables = $compiledRoute->getVariables();

        // route parameters
        $routeParameters = array();

        // set variables value
        foreach ($variables as $variable) {

            // read the variable value from $defaultVariables
            if (array_key_exists($variable, $defaultVariables)) {
                $routeParameters[$variable] = $defaultVariables[$variable];

                // search the $variable key in bundle configuration: dynamic_routes_default_params
            } else if (array_key_exists($variable, $this->dynamic_routes_default_params)) {
                $routeParameters[$variable] = $this->dynamic_routes_default_params[$variable];
            }
        }

        // try to generate the route
        try {
            return $this->router->generate($name, $routeParameters);
        } catch (\Exception $e) {
            // no exception is thrown, the url is simply not added to the list
        }

        return null;
    }

    /**
     * check if the Route $route is exposed
     *
     * @param $route
     * @return Boolean
     */
    public function isRouteExposed(Route $route)
    {
        $routeDefaults = $route->getDefaults();
        $_controller = $routeDefaults['_controller'];

        // check if an "expose" parameter is set in the controller
        $routeExposedByRouteOption = $this->getRouteExposedByRouteOption($route);
        if (null !== $routeExposedByRouteOption) {
            return $routeExposedByRouteOption;
        }

        // check if the bundles is set in the configurations file
        if ($this->isRouteExposedByBundle($_controller)) {
            return true;
        }

        return false;
    }

    /**
     * generate regex string to filter the controller of a route
     *
     * the regex is an OR concatenation of the bundles' namespaces set by the user in config.yml
     *
     * eg: (^Acme\\FooBundle)|(^Acme)
     */
    private function generateLoadedBundlesRegex()
    {
        foreach ($this->container->get('kernel')->getBundles() as $bundle) {

            if (in_array($bundle->getName(), $this->config['exposed_routes']['bundles'])) {

                if ($this->loadedBundlesRegex != '') {
                    $this->loadedBundlesRegex .= '|';
                }

                $this->loadedBundlesRegex .= "(^".addslashes($bundle->getNamespace()).")";
            }
        }

        return ($this->loadedBundlesRegex != '') ? $this->loadedBundlesRegex : null;
    }

    /**
     * Check if a route is exposed by including a bundle name under the 'exposed_routes.bundles' key in config.yml
     *
     * @param $_controller
     * @return bool
     */
    private function isRouteExposedByBundle($_controller)
    {
        if ($this->loadedBundlesRegex != "" && preg_match($this->loadedBundlesRegex, $_controller)) {
            return true;
        }

        return false;
    }

    /**
     * check if a route must be included to generate urls by checking the "options" attribute
     *
     * a route can be exposed by setting the "ci_metatags_expose" options key to true
     *
     * eg: @Route("/myaction", name="my_action", options={"ci_metatags_expose"=true})
     *
     * @param \Symfony\Component\Routing\Route $route
     * @return bool
     */
    private function getRouteExposedByRouteOption(Route $route)
    {
        $routeOptions = $route->getOptions();

        if (array_key_exists('ci_metatags_expose', $routeOptions)) {
            if (true === $routeOptions['ci_metatags_expose']) {
                return true;
            } else if (false === $routeOptions['ci_metatags_expose']) {
                return false;
            }
        }

        return null;
    }

    /**
     * get all url stored in database
     *
     * @return array of urls
     */
    private function getDatabaseUrls() {
        $metatags = $this->em->getRepository('CopiaincollaMetaTagsBundle:Metatag')->findAll();
        $arrDatabaseUrls = array();

        foreach($metatags as $metatag) {
            $arrDatabaseUrls[] = $metatag->getUrl();
        }

        return $arrDatabaseUrls;
    }

    /**
     * Purge the array of routes/urls from the urls already associated (currently stored in database)
     *
     * @param $routes
     */
    private function purgeRoutesArrayFromAlreadyAssociatedUrls($routes)
    {
        // get all url stored in database
        $databaseUrls = $this->getDatabaseUrls();

        foreach ($routes as $route => $urls) {
            foreach ($urls as $k => $url) {
                if (in_array($url, $databaseUrls)) {
                    unset($routes[$route][$k]);
                }
            }
        }

        return $routes;
    }

}
